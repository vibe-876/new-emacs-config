:PROPERTIES:
:header-args: :session init :tangle init.el
:END:
#+title: Emacs Config File
#+author: Camilla A.
#+startup: overview


* Introduction
Welcome to my config file.
You're welcome to use any bits of this if you want to, but I can't promise that it will work :) .

This is a [[https://en.wikipedia.org/wiki/Literate_programming][literate file]], that is, the program it documents is generated from this file -- I never edit the source file directly, only this file.
The file can be tangled (IE the source code can be written into [[file:init.el][init.el]]) by running
#+begin_src elisp :tangle no
  (org-babel-tangle)
#+end_src

Alternatively, the elisp file this tangles to is also in this repo, for easy loading, in case you want to use my config (for some reason).
Note that specific bits of code can be ignored by the tangling, such as the above.
I prefer this approach to programming, because I always aim to writing programs to me is first and foremost, an art.
Thus, I want people to be able to actually read my work.

* Package Management

This does 2 things:
- disable the standard package system starting
- bootstrap [[https://github.com/radian-software/straight.el][straight.el]]

Straight is a package manager for Emacs, and I prefer it to the standard one.
It lets me clone packages directly from git repos, which I prefer to the standard method.
#+begin_src elisp
  (setq package-enable-at-startup nil)

  (defvar bootstrap-version)
  (let ((bootstrap-file
  	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
  	(bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
  	  (url-retrieve-synchronously
  	   "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
  	   'silent 'inhibit-cookies)
  	(goto-char (point-max))
  	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t
        use-package-always-ensure nil)
#+end_src


From this point onwards, this document will separated into two sections: Reading, and Writing.
I've chosen to lay the file out like this because the way I see it, everything that a text editor does can be described by these two operations.

* Reading
[[https://magit.vc/][Magit]] is an amazing git porcelain.
It's the only git "thing" that I'd happy use instead of the standard command-line version.
#+begin_src elisp
  (use-package magit)
#+end_src


I use a collection of themes called [[https://github.com/protesilaos/ef-themes][ef-themes]], created by Prot.
I also like to disable the tool bar, menu bar, and scroll bar, because I work almost entirely from the keyboard, and find them distracting.
#+begin_src elisp
  (use-package ef-themes
    :defer nil
    :config
    (load-theme 'ef-dream t)
    (set-frame-parameter nil 'alpha-background 98))

  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src


[[https://github.com/skeeto/elfeed][elfeed]] is a [[https://en.wikipedia.org/wiki/Rss][RSS]] reader for Emacs.
It is the best RSS reader I have ever used (which is admittedly a rather short list); it's got some really good tagging and searching filters, and far more importantly, I can easily extend it with elisp.
As it would happen, I have a few extra procedures written for it.
I find RSS to be a much nicer way of interacting with the web than the modern alternative, I'd recommend giving it a try if you've not before.
#+begin_src elisp
  (use-package elfeed
    :defer t
    :bind ("C-c e" . elfeed)
    :after (emms)
    :config
    (setq elfeed-feeds
  	  '(("https://irreal.org/blog/?feed=rss2" blog emacs)
  	    ("http://yummymelon.com/devnull/feeds/all.atom.xml" blog emacs)
  	    ("https://protesilaos.com/codelog.xml" blog emacs)
  	    ("https://protesilaos.com/poems.xml" blog poems)
  	    ("https://protesilaos.com/commentary.xml" blog life)
  	    ("https://shaiyaj.github.io/notes/feed.xml" blog)
  	    ("https://xkcd.com/rss.xml" comic)
  	    ("https://www.smbc-comics.com/comic/rss" comic)
  	    ("https://archlinux.org/feeds/news/" arch linux tech)
  	    ("https://www.debian.org/security/dsa" debian linux tech)
  	    ("https://wolfgirl.dev/blog/rss.xml" blog tech prog)
  	    ("https://izzys.casa/index.xml" blog tech prog)
  	    ("https://faultlore.com/blah/rss.xml" blog tech prog)
  	    ("https://nexy.blog/feed_rss_created.xml" blog tech)
  	    ("https://welltypedwit.ch/rss.xml" tech blog)
  	    ("https://risky.biz/feeds/risky-business-news/" tech security podcast)
  	    ;; Leadhead
  	    ("https://www.youtube.com/feeds/videos.xml?channel_id=UC3_kehZbfRz-KrjXIqeIiPw" blog video)
  	    ;; Wendigoon
  	    ("https://www.youtube.com/feeds/videos.xml?channel_id=UC3cpN6gcJQqcCM6mxRUo_dA" video spooky)
  	    ;; SOG
  	    ("https://www.youtube.com/feeds/videos.xml?channel_id=UCtMVHI3AJD4Qk4hcbZnI9ZQ" video blog)
  	    ;; Philosophy Tube
  	    ("https://www.youtube.com/feeds/videos.xml?channel_id=UC2PA-AKmVpU6NKCGtZq_rKQ" video phil)
  	    ("https://www.youtube.com/feeds/videos.xml?channel_id=UCctWUfejRybO1cCT6DmIRqQ" video speedrun))))
#+end_src

~emms~ is the Emacs MultiMedia System.
I mainly use it with ~elfeed~, so that I can listen to podcasts, with a simple ~A~ on the entry.
#+begin_src elisp
  (use-package emms
    :config
    (emms-all)
    (setq emms-player-list '(emms-player-mpv)))
#+end_src

Elpher is a gopher and gemini client.
I've been getting disillusioned with the web recently, and both gopher and gemini have been a breath of fresh air.
Gopher and gemini are both alternate communication protocols for the internet, and much like RSS, I'd recommend giving them a shot at least once in your life.
#+begin_src elisp
  (use-package elpher)
#+end_src

~ido-mode~ changes buffer searching and switching, making it a lot more efficient.
#+begin_src elisp
  (ido-mode 1)
#+end_src

~ibuffer~ is a drop-in replacement for the standard buffer list.
I view it as the ~ido-mode~ of the buffer list.
#+begin_src elisp
    (use-package ibuffer
      :ensure nil
      :straight nil
      :bind ("C-x C-b" . ibuffer)
      :hook (ibuffer-mode . (lambda ()
    			  (ibuffer-switch-to-saved-filter-groups "Buffers")))
      :config
      (setq ibuffer-expert nil
    	ibuffer-saved-filter-groups '(("Buffers"
    				       ("Programming" (or (mode . clojure-mode)
    							  (mode . cider-mode)
    							  (mode . c-mode)
    							  (mode . java-mode)
    							  (mode . emacs-lisp-mode)
    							  (mode . mhtml-mode)
    							  (mode . makefile-gmake-mode)))
    				       ("Documents" (or (mode . org-mode)
    							(mode . markdown-mode)
    							(mode . reader-mode)))
    				       ("Magit" (or (mode . magit-status-mode)
    						    (mode . magit-diff-mode)
    						    (mode . magit-process-mode)))
    				       ("Emacs" (or
    						 (mode . emacs-lisp-mode)
    						 (name . "^\\*Help\\*$")
    						 (name . "^\\*Custom.*")
    						 (name . "^\\*Org Agenda\\*$")
    						 (name . "^\\*info\\*$")
    						 (name . "^\\*scratch\\*$")
    						 (name . "^\\*Backtrace\\*$")
    						 (name . "^\\*Messages\\*$")
    						 (name . "^\\*GNU Emacs\\*$")
    						 (mode . emacs-news-view-mode)))
    				       ("Unsaved" (modified))))))
#+end_src

* Writing
As I am a lisp programmer, ~paredit~ is essential for me.
~paredit~ does "electric brackets", which for me at least, makes lisp feel completely natural, more so than any other language for thinking, in most cases at least.
#+begin_src elisp
  (use-package paredit
    :hook ((emacs-lisp-mode . enable-paredit-mode)
  	 (clojure-mode    . enable-paredit-mode)
  	 (scheme-mode     . enable-paredit-mode))
    :after (cider))
#+end_src

~rainbow-delimiters~ is another really useful one.
It (as the name would imply) puts pretty colours onto the brackets, which makes lisp /really/ easy to read.
Paired with ~paredit~, this makes lisp a breeze.

#+begin_src elisp
  (use-package rainbow-delimiters
    :defer nil
    :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
  	 (clojure-mode    . rainbow-delimiters-mode)
  	 (scheme-mode     . rainbow-delimiters-mode))
    :after (cider))
#+end_src

[[https://cider.mx/][Cider]] is a package for Clojure (my beloved <3), which extends Emacs support for it.
It boosts the interactivity for Clojure, so that we can do lisp in the most enjoyable way possible.

It gives:
- a REPL (Read Evaluate Print Loop), that supports stuff like [[https://leiningen.org/][Leiningen]]
- a really good debugger
- definition look ups
- good support for testing

And so much more that I love.

#+begin_src elisp
  (use-package cider)
#+end_src

[[https://www.nongnu.org/geiser/][Geiser]] is like Cider or [[https://github.com/joaotavora/sly][Sly]], but for generic schemes.
I've got the [[https://www.gnu.org/software/guile/][Guile]] version installed, because that's the scheme that I use.

[[http://xahlee.info/comp/wizard_book.html][Have you read your SICP today?]]
#+begin_src elisp
  (use-package geiser
    :hook ((scheme-mode . geiser-mode)))

  (use-package geiser-guile
    :after geiser)
#+end_src


[[https://lean-lang.org/][Lean 4]] is a powerful programming language, with the ability to formalise mathematics.
I'm doing (at the time of writing, late 2025) a second year undergraduate in computer science and mathematics, so -- for obvious reasons -- this language is appealing to me.
For using Lean 4 in Emacs, I use the wonderful [[https://github.com/leanprover-community/lean4-mode][lean4-mode]].
#+begin_src elisp
  (use-package dash)
  (use-package lsp-mode)

  (use-package lean4-mode
    :commands lean4-mode
    :straight (lean4-mode :type git :host github
  			:repo "leanprover-community/lean4-mode"
  			:files ("*.el" "data"))
    :config
    (add-to-list 'exec-path (concat (getenv "HOME")
  				  "/.elan/bin")))
#+end_src

Haskell is a beautiful declarative, lazy, and functional programming language.
#+begin_src elisp
  (use-package haskell-mode
    :bind
    (:map haskell-mode-map ("C-c C-c" . haskell-compile))
    (:map haskell-cabal-mode-map ("C-c C-c" . haskell-compile))
    :config
    (let ((cam-ghcup-path (expand-file-name "~/.ghcup/bin")))
      (setenv "PATH" (concat (getenv "PATH") ":" cam-ghcup-path))
      (add-to-list 'exec-path cam-ghcup-path)))
#+end_src

My University course requires that I use Java (ew).
I'll die before I willingly program in IntelliJ, so Emacs needs to be able to do Java things.

At the moment, this expects a directory structure for the project to have a ~build.xml~ for [[https://ant.apache.org/][ant]] at its root, as well as a directory called ~build~.
~build~ is where it'll look for the Java class files in question.
This is good enough for me for now, but I may rewrite it at some point, using something like [[https://github.com/bbatsov/projectile][projectile]] and ~directory-files-recursively~.

Note, you may want to change ~build.xml~ to something else in the hook, it's just what I call my build files for ant.
#+begin_src elisp
  (defun cam/run-java (java-file)
    "Simple running of a java program, using comint mode.
  See `cam/inferior-java-mode'."
    (interactive "bInit File: ")
    (unless (executable-find "java")
        (message "ERROR: Couldn't find Java executable!"))
    
    (let* ((class-file (file-name-base java-file))
  	 (inferior-buffer-name "Java Process")
  	 (default-directory (concat default-directory "../build")))
      (switch-to-buffer (concat "*Java Process*"))
      (erase-buffer)
      (make-comint-in-buffer inferior-buffer-name
  			   nil
  			   (executable-find "java")
  			   nil
  			   class-file)))


  (add-hook 'java-mode-hook (lambda () (local-set-key (kbd "C-c C-l") 'cam/run-java)))
  (add-hook 'java-mode-hook (lambda ()
  			    (setq-local compile-command "ant -emacs -find build.xml")))
#+end_src

Where to begin with Org Mode...
[[https://orgmode.org/][Org]] is -- at its simplest -- a markup language that's pretty good at scheduling and literate programming.
If you've never given it a shot, I'd recommend trying it.
#+begin_src elisp
  (use-package org
    :straight nil
    :ensure nil
    :bind (("C-c a" . org-agenda)
  	 ("C-c c" . org-capture))
    :config
    (setq org-directory (concat (getenv "HOME") "/Documents/Agenda/")
  	org-agenda-files (list org-directory)
  	org-todo-keywords '((sequence "TODO(t)" "WAIT(w!)" "|" "CANCEL(c!)" "DONE(d!)"))
  	org-default-notes-file (concat (car org-agenda-files) "notes.org")
          org-capture-templates '(("t" "Todo")
  				("tt" "Standard Thing" entry (file org-default-notes-file)
  				 "* TODO %?\n %a\n DEADLINE: %^t")
  				("tw" "Work Thing" entry (file org-default-notes-file)
  				 "* TODO %?\n SCHEDULED: %^t")
  				("a" "Assignment" entry (file "assignments.org")
  				 "* TODO %?\n DEADLINE: %^t")
  				("d" "Diary Entry" entry (file "diary.org")
  				  "* %?\n %t")
  				("i" "Ideas")
  				("ip" "Programming Ideas" entry (file "ideas.org")
  				 "* %?\n %i\n\n %t"))))
#+end_src

I rarely use [[https://www.markdownguide.org/][markdown]] myself, but I have a few friends that do, so I keep this installed
#+begin_src elisp
  (use-package markdown-mode)
#+end_src

#+begin_src elisp
  (use-package typst-ts-mode
    :straight '(:type git :host codeberg :repo "meow_king/typst-ts-mode"))
#+end_src
